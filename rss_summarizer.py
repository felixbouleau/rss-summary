#!/usr/bin/env python3
"""
RSS Feed Summarizer using Claude AI

This script fetches RSS feed content from a provided URL, processes entries from the last 24 hours,
and uses Anthropic's Claude AI to generate a summary of the content.
"""

import os
import sys
import time
import datetime
import feedparser
import yaml
from dateutil import parser as date_parser
from anthropic import Anthropic
from feedgen.feed import FeedGenerator # Add feedgen import
import http.server
import socketserver
import threading
import functools # For http server directory binding

def get_entries_from_last_24h(feed_url):
    """
    Fetch entries from the RSS feed that were published in the last 24 hours.
    """
    try:
        feed = feedparser.parse(feed_url)
        if not feed.entries:
            print("Error: No entries found in the feed")
            sys.exit(1)
            
        # Get current time
        now = datetime.datetime.now(datetime.timezone.utc)
        cutoff = now - datetime.timedelta(hours=24)
        
        # Filter entries from the last 24 hours
        recent_entries = []
        for entry in feed.entries:
            if hasattr(entry, 'published'):
                try:
                    pub_date = date_parser.parse(entry.published)
                    if pub_date > cutoff:
                        recent_entries.append(entry)
                except Exception as e:
                    print(f"Warning: Could not parse date for entry: {e}")
        
        return recent_entries
    except Exception as e:
        print(f"Error fetching or parsing RSS feed for {feed_url}: {e}")
        # Return empty list instead of exiting, so other feeds can be tried
        return [] 

def load_feeds_from_yaml():
    """
    Load feed URLs from a YAML file specified by the RSS_FEEDS_CONFIG env var,
    defaulting to 'feeds.yml'.
    """
    # Get config file path from env var, default to 'feeds.yml'
    filepath = os.environ.get("RSS_FEEDS_CONFIG", "feeds.yml")
    print(f"Loading feeds from: {filepath}") # Add info message

    try:
        with open(filepath, 'r') as f:
            config = yaml.safe_load(f)
            if config and 'feeds' in config and isinstance(config['feeds'], list):
                # Extract URLs from the list of dictionaries
                urls = [feed.get('url') for feed in config['feeds'] if isinstance(feed, dict) and 'url' in feed]
                if not urls:
                    print(f"Error: No valid feed URLs found in {filepath}")
                    sys.exit(1)
                return urls
            else:
                print(f"Error: Invalid format in {filepath}. Expected a 'feeds' list with 'url' keys.")
                sys.exit(1)
    except FileNotFoundError:
        print(f"Error: Configuration file {filepath} not found.")
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"Error parsing YAML file {filepath}: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred while loading feeds: {e}")
        sys.exit(1)

# --- RSS Feed Generation ---

def generate_rss_feed(summary_text, feed_file_path):
    """
    Generates an RSS feed file with the summary as the latest entry.
    Overwrites the file if it exists.
    """
    fg = FeedGenerator()
    fg.title('AI Generated Feed Summary')
    # Use the feed file path itself as the link for simplicity
    feed_link = f"file://{os.path.abspath(feed_file_path)}" 
    fg.link(href=feed_link, rel='alternate')
    fg.description('Daily summary of RSS feeds generated by Claude AI.')
    fg.language('en')

    # Create a single entry for the latest summary
    fe = fg.add_entry()
    now = datetime.datetime.now(datetime.timezone.utc)
    entry_title = f"Summary for {now.strftime('%Y-%m-%d %H:%M:%S UTC')}"
    fe.title(entry_title)
    # Create a unique ID based on timestamp
    fe.id(f"urn:uuid:{now.isoformat()}")
    fe.link(href=feed_link) # Link entry back to the feed itself
    # Use content() with type='html' instead of description()
    fe.content(summary_text, type='html') 
    fe.pubDate(now)

    try:
        # Ensure the directory exists
        os.makedirs(os.path.dirname(feed_file_path), exist_ok=True)
        # Generate the RSS feed file
        fg.rss_file(feed_file_path, pretty=True)
        print(f"RSS feed updated successfully: {feed_file_path}")
    except Exception as e:
        print(f"Error writing RSS feed file: {e}")


# --- HTTP Server ---

def start_http_server(directory, port):
    """Starts a simple HTTP server in a background thread."""
    Handler = functools.partial(http.server.SimpleHTTPRequestHandler, directory=directory)
    httpd = socketserver.TCPServer(("", port), Handler)
    
    print(f"Serving RSS feed from directory '{directory}' on port {port}")
    print(f"Feed URL: http://localhost:{port}/feed.xml") # Assuming feed is named feed.xml
    
    # Run the server in a separate thread
    server_thread = threading.Thread(target=httpd.serve_forever)
    server_thread.daemon = True # Allows program to exit even if thread is running
    server_thread.start()


# --- Core Logic ---

def format_entries_for_prompt(entries):
    """
    Format RSS entries into a text format for the prompt.
    """
    formatted_text = ""
    
    for i, entry in enumerate(entries, 1):
        formatted_text += f"POST {i}:\n"
        formatted_text += f"Title: {entry.title}\n"
        formatted_text += f"Link: {entry.link}\n"
        
        if hasattr(entry, 'published'):
            formatted_text += f"Published: {entry.published}\n"
            
        if hasattr(entry, 'summary'):
            formatted_text += f"Summary: {entry.summary}\n"
        elif hasattr(entry, 'description'):
            formatted_text += f"Description: {entry.description}\n"
            
        formatted_text += "\n---\n\n"
    
    return formatted_text

def get_prompt():
    """
    Read the prompt from the prompt.txt file.
    """
    try:
        with open("prompt.txt", "r") as f:
            return f.read()
    except Exception as e:
        print(f"Error reading prompt file: {e}")
        sys.exit(1)

def summarize_with_claude(entries_text):
    """
    Use Claude API to summarize the entries.
    """
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        print("Error: ANTHROPIC_API_KEY environment variable not set")
        sys.exit(1)
    
    client = Anthropic(api_key=api_key)
    prompt_text = get_prompt()
    
    # Get system prompt from env var, with a default requesting HTML formatting
    default_system_prompt = "Summarize the provided content accurately and concisely. Format the output using HTML tags (e.g., <h2>, <h3>, <p>, <ul>, <li>) for structure and readability."
    system_prompt = os.environ.get("CLAUDE_SYSTEM_PROMPT", default_system_prompt)
    print(f"Using system prompt: '{system_prompt}'")

    try:
        message = client.messages.create(
            model="claude-3-5-haiku-20241022",
            max_tokens=1024,
            system=system_prompt, # Use the configured system prompt
            messages=[
                {
                    "role": "user",
                    "content": f"{prompt_text}\n\nHere are the Reddit posts from the last 24 hours:\n\n{entries_text}"
                }
            ]
        )
        return message.content[0].text
    except Exception as e:
        print(f"Error calling Claude API: {e}")
        # Don't exit the whole script on API error, just return None
        # sys.exit(1) 
        return None

def run_summary_cycle(feed_file_path):
    """
    Performs one cycle of fetching, summarizing, and saving the feed.
    """
    print(f"\n--- Starting summary cycle at {datetime.datetime.now()} ---")
    feed_urls = load_feeds_from_yaml() 

    if not feed_urls:
        print("No feed URLs loaded. Skipping cycle.")
        return

    all_entries = []
    # Get entries from the last 24 hours for each feed
    for feed_url in feed_urls:
        print(f"Fetching entries from: {feed_url}")
        entries = get_entries_from_last_24h(feed_url)
        if entries:
            all_entries.extend(entries)
        else:
            print(f"No recent entries found for: {feed_url}")

    if not all_entries:
        print("No new entries found across all feeds in the last 24 hours.")
        # Don't exit, just skip generating a summary for this cycle
        return 

    # Sort entries by published date (newest first)
    all_entries.sort(key=lambda x: date_parser.parse(x.published) if hasattr(x, 'published') else datetime.datetime.min.replace(tzinfo=datetime.timezone.utc), reverse=True)

    # Format entries for the prompt
    entries_text = format_entries_for_prompt(all_entries)
    
    # Get summary from Claude
    summary = summarize_with_claude(entries_text)

    if summary:
        # Generate the RSS feed file
        generate_rss_feed(summary, feed_file_path)
    else:
        print("Failed to generate summary from Claude.")
    
    print(f"--- Summary cycle finished at {datetime.datetime.now()} ---")


def main():
    """
    Main function to set up the server and run the summary loop.
    """
    # Configuration from environment variables
    output_dir = os.environ.get("RSS_OUTPUT_DIR", "./rss")
    server_port = int(os.environ.get("RSS_SERVER_PORT", 8080))
    refresh_interval = int(os.environ.get("RSS_REFRESH_INTERVAL", 86400)) # Default 24 hours
    feed_filename = "feed.xml"
    feed_file_path = os.path.join(output_dir, feed_filename)

    print("--- RSS Summarizer Service ---")
    print(f"Output Directory: {os.path.abspath(output_dir)}")
    print(f"Server Port: {server_port}")
    print(f"Refresh Interval: {refresh_interval} seconds")
    print(f"Feed File: {feed_file_path}")
    print("-----------------------------")

    # Ensure output directory exists
    try:
        os.makedirs(output_dir, exist_ok=True)
    except Exception as e:
        print(f"Error creating output directory '{output_dir}': {e}")
        sys.exit(1)

    # Start the HTTP server in a background thread
    start_http_server(output_dir, server_port)

    # Run the summary generation loop
    while True:
        try:
            run_summary_cycle(feed_file_path)
            print(f"Sleeping for {refresh_interval} seconds until the next cycle...")
            time.sleep(refresh_interval)
        except KeyboardInterrupt:
            print("\nShutdown requested. Exiting.")
            sys.exit(0)
        except Exception as e:
            print(f"\n--- An unexpected error occurred in the main loop: {e} ---")
            print(f"--- Will retry after {refresh_interval} seconds ---")
            time.sleep(refresh_interval)


if __name__ == "__main__":
    main()
